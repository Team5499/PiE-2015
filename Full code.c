#pragma config(Sensor, in6,    lineTrackerLeft, sensorLineFollower)
#pragma config(Sensor, in7,    lineTrackerRight, sensorLineFollower)
#pragma config(Sensor, dgtl7,  panEnc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl10, tableSwitch,    sensorTouch)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port2,           leftLinkMotor, tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           dustPanMotor,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightLinkMotor, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(30) //The auto is 30 secs
#pragma userControlDuration(120) //The teleop is 2 mins

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Whenever this user program is run, the duration is automatically sent to the VEX master
// processor. The master CPU will only accept these commands once per power=on cycle. So, it's
// best to power cycle your VEX to ensure that they get recognized in case you were
// previously running a standard competition program with different durations.


// Testing Via VEXNET Using ROBOTC IDE
// ==================================================
//
// It is not necessary to own a VEXNET switch. ROBOTC has a test window that allows the same functionality.
// The test window has three buttons for "DISABLE", "AUTONOMOUS", "USER CONTROL".
//
// 1. Open the ROBOTC Debugger. Then open the "Competition Control" Debugger window.
//
// 2. Start your Driver Skills program running.
//
// 3. Click the "DISABLED" button on the "Competition Control" window.
//
// 4. Click the "USER CONTROL" button on the "Competition Control" window.
//
// 5. You need to manually time the 60 second duration.
//
// 6. Click the "DISABLED" button on the "Competition Control" window.
//
// 7. Repeat from step (4) to run subsequent test runs. There's no need to reset the VEX or
//    restart your user program.
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
* Before game
* All activities that occur before the competition starts
* Example: clearing encoders, setting servo positions, ...
**/
void pre_auton()
{
	int final panEncFullExtend = 200; //if rotation of the shaft does not exceed 250 degs in total, can use a pot
	int final panEncFullRetract = -200;
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	clearTimer(T1); //it was spelled with "c" twice, while once with "C"
}

/**
* Auto
**/
task autonomous()
{
	//Create and set the threshold for the Line Tracking Sensors.
	//LineTrackers return 0-4095, where high values are dark and low values are light.
	int lfThreshold;
	lfThreshold = 2500;

	//Loop forever.
	while(true)
	{
		//Lower linkage to the floor and fully extend the pan at the start of auto
		if(panSwitch == 0 || SensorValue(panEnc) < panEncFullExtend){
			while(panSwitch == 0){
				motor[leftLinkMotor] = -40;
				motor[rightLinkMotor] = -40;
			}
			while(SensorValue(panEnc) < panEncFullExtend){
				motor[dustPanMotor] = 40;
			}
		} else{
			//If table switch is pressed (if a table has been found), drive forward slowly while rasing the linkage. This will raise the table
			if(SensorValue(tableSwitch)){
				motor[leftMotor]  = 10;
				motor[rightMotor] = 10;
				motor[leftLinkMotor] = 30;
				motor[rightLinkMotor] = 30;
			} else{
				//If both sensors see dark...
				if(SensorValue(lineTrackerLeft) > lfThreshold && SensorValue(lineTrackerRight) > lfThreshold) {
					//...move forward.
					motor[leftMotor]  = 40; //127 is full forward, -127 is full reverse or it might be out of 100%
					motor[rightMotor] = 40;
				}
				//If both sensors see light... (this is to clear the yellow tape in the starting box)
				else if(SensorValue(lineTrackerLeft) < lfThreshold && SensorValue(lineTrackerRight) < lfThreshold) {
					//...move forward.
					motor[leftMotor]  = 40;
					motor[rightMotor] = 40;
				}
				//If the left sensor sees light...
				else if(SensorValue(lineTrackerLeft) < lfThreshold){ //could be sersorValue[sensorName]
					//...counter-steer to the left.
					motor[leftMotor]  = 0;
					motor[rightMotor] = 40;
				}
				//If the right sensor sees light...
				else if(SensorValue(lineTrackerRight) < lfThreshold) {
					//...counter-steer to the right.
					motor[leftMotor]  = 40;
					motor[rightMotor] = 0;
				}
				else {
					motor[leftMotor] = 0;
					motor[rightMotor] = 0;
				}
			}
		}
	}
}

/**
* Teleop
**/
task usercontrol()
{
	while (true)
	{
		//User control code goes in this while loop
		motor[leftMotor]  = vexRT[Ch3];   // Left Joystick Y value
		motor[rightMotor] = vexRT[Ch2];   // Right Joystick Y value

		//4-Bar Linkage
		//if button 5D is pressed, raise
		if(vexRT[Btn5D] == 1){
			motor[leftLinkMotor] = 80;
			motor[rightLinkMotor] = 80;
		}
		//if button 6D is pressed, lower
		else if (vexRT[Btn6D] == 1){
			motor[leftLinkMotor] = -80;
			motor[rightLinkMotor] = -80;
		}
		//otherwise, do not do anything
		else{
			motor[leftLinkMotor] = 0;
			motor[rightLinkMotor] = 0;
		}

		//Dustpan
		if(vexRT[Btn8R] == 1){ //change button according to what the driver wants
			if(SensorValue(panEnc < panEncFullExtend)){
				motor[dustPanMotor] = 80; //extend
			}
		} else if(vexRT[Btn8L]){
			if(SensorValue(panEnc < panEncFullRetract)){
				motor[dustPanMotor] = -80; //retract
			}
		} else {
			motor[dustPanMotor] = 0;
		}
	}
}
