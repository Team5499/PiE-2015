#pragma config(Sensor, in1,    linkPot,        sensorPotentiometer)
#pragma config(Sensor, in7,    lineTrackerLeft, sensorLineFollower)
#pragma config(Sensor, in8,    lineTrackerRight, sensorLineFollower)
#pragma config(Sensor, dgtl1,  frontPanSwitch, sensorTouch)
#pragma config(Sensor, dgtl2,  backPanSwitch,  sensorTouch)
#pragma config(Sensor, dgtl3,  tableSwitch,    sensorTouch)
#pragma config(Sensor, dgtl4,  topElevSwitch,  sensorTouch)
#pragma config(Sensor, dgtl5,  bottomElevSwitch, sensorTouch)
#pragma config(Motor,  port1,           leftMotor1,    tmotorVex393_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port2,           leftMotor2,    tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           leftElevMotor, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           dustPanMotor,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightElevMotor, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           rightMotor2,   tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          rightMotor1,   tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(30) //The auto is 30 secs
#pragma userControlDuration(120) //The teleop is 2 mins

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Whenever this user program is run, the duration is automatically sent to the VEX master
// processor. The master CPU will only accept these commands once per power=on cycle. So, it's
// best to power cycle your VEX to ensure that they get recognized in case you were
// previously running a standard competition program with different durations.


// Testing Via VEXNET Using ROBOTC IDE
// ==================================================
// It is not necessary to own a VEXNET switch. ROBOTC has a test window that allows the same functionality.
// The test window has three buttons for "DISABLE", "AUTONOMOUS", "USER CONTROL".
// 1. Open the ROBOTC Debugger. Then open the "Competition Control" Debugger window.
// 2. Start your Driver Skills program running.
// 3. Click the "DISABLED" button on the "Competition Control" window.
// 4. Click the "USER CONTROL" button on the "Competition Control" window.
// 5. You need to manually time the 60 second duration.
// 6. Click the "DISABLED" button on the "Competition Control" window.
// 7. Repeat from step (4) to run subsequent test runs. There's no need to reset the VEX or restart your user program.

///**
//* Variables
//**/
//int desLinkPos;
//int upLinkLim;
//int lowLinkLim;

/**
* extends the pan if the limit switch is not pressed
**/
void extendPan(){
	if(SensorValue(backPanSwitch) == 0){
		motor[dustPanMotor] = 80; //is this too fast?
		} else {
		writeDebugStream("Pan is fully extended");
	}
}

/**
* retracts the pan if the limit switch is not pressed
**/
void retractPan(){
	if(SensorValue(frontPanSwitch) == 0){
		motor[dustPanMotor] = -80; //is this too fast?
		} else{
		writeDebugStream("Pan is fully retracted");
	}
}

///**
//* Moves the Elevator to the desired position. There may be issues with it overshooting and oscilating a lot before settling.
//**/
//void moveElevator(int desiredPos){
//	if (desiredPos < SensorValue(linkPot) && (desiredPos <= upLinkLim || desiredPos >= lowLinkLim)){
//		while(SensorValue(linkPot) != desiredPos){
//			motor[leftLinkMotor] = 70;
//			motor[rightLinkMotor] = 70;
//		}
//	}
//	if (desiredPos > SensorValue(linkPot) && (desiredPos <= upLinkLim || desiredPos >= lowLinkLim)){
//		while(SensorValue(linkPot) != desiredPos){
//			motor[leftLinkMotor] = -20;
//			motor[rightLinkMotor] = -20;
//		}
//	}
//}

/**
* raises Elevator if the pot is not at the upper limit
**/
void raiseElevator(){
	//if(SensorValue(linkPot) < upLinkLim){ //250 is max
	if(SensorValue(topElevSwitch) == 1){
		motor[leftElevMotor] 	= 100;//is this in percent?
		motor[rightElevMotor] = 100;
	}
	//}
}

/**
* lowers Elevator if the pot is not at the upper limit
**/
void lowerElevator(){
	//if(SensorValue(linkPot) > lowLinkLim){
	if(SensorValue(bottomElevSwitch) == 1){
		motor[leftElevMotor] 	= -50; //is this too fast
		motor[rightElevMotor] = -50;
	}
	//}
}

/**
* Flips table by slowly going forward and raising the Elevator for either 2 secs or until btn8d is pressed, whichever comes first.
**/
void flipTable(){
	int i = 0; //changes with the first loop of the while loop
	int startTime;
	if(i == 0){
		startTime = time1[T1]; //keeps start time without having to clear a timer
	}
	while(true){
		i = 1;
		motor[leftMotor1]  		= 50;
		motor[leftMotor2]  		= 50;
		motor[rightMotor1] 		= 50;
		motor[rightMotor2] 		= 50;
		raiseElevator();
		if(time1[T1] - startTime == 2000 || vexRT[Btn8D] == 1){ //2 secs //manual control over an infinite loop
			motor[leftMotor1] 		= 0;
			motor[leftMotor2] 		= 0;
			motor[rightMotor1] 		= 0;
			motor[rightMotor2]    = 0;
			motor[leftElevMotor]  = 0;
			motor[rightElevMotor] = 0;
			break;
		}
	}
}

void stopAllMotors(){
	if(vexRT[] == 1){
		while(true){
			motor[leftMotor1] 		= 0;
			motor[leftMotor2] 		= 0;
			motor[rightMotor1] 		= 0;
			motor[rightMotor2]    = 0;
			motor[leftElevMotor]  = 0;
			motor[rightElevMotor] = 0;
			motor[dustPanMotor]		= 0;
			if(vexRT[] == 1)
				break;
		}
	}
}

/**
* Before game
* All activities that occur before the competition starts
* Example: clearing encoders, setting servo positions, ...
**/
void pre_auton() {
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	clearTimer(T1); //it was spelled with "c" twice, while once with "C"
	//desLinkPos = 0;
	//upLinkLim = 2065;
	//lowLinkLim = 2375;
}

/**
* Auto
**/
task autonomous() {
	//Create and set the threshold for the Line Tracking Sensors.
	//LineTrackers return 0-4095, where high values are dark and low values are light.
	int lfThreshold = 2500;

	//Loop forever.
	while(true) {
		//Lower Elevator to the floor and fully extend the pan at the start of auto
		if(SensorValue(linkPot) > 0 || SensorValue(backPanSwitch) == 0){
			//moveLinkage(lowLinkLim);
			lowerElevator();
			extendPan();
			} else{
			//If table switch is pressed (if a table has been found), drive forward slowly while rasing the Elevator. This will theoretically raise the table
			if(SensorValue(tableSwitch) == 1){
				flipTable();
				} else{
				//If both sensors see dark move forward.
				if(SensorValue(lineTrackerLeft) > lfThreshold && SensorValue(lineTrackerRight) > lfThreshold) {
					motor[leftMotor1]  = 40; //127 is full forward, -127 is full reverse or it might be out of 100%
					motor[leftMotor2]  = 40;
					motor[rightMotor1] = 40;
					motor[rightMotor2] = 40;
				}
				//If both sensors see light move forward (this is to clear the yellow tape in the starting box)
				else if(SensorValue(lineTrackerLeft) < lfThreshold && SensorValue(lineTrackerRight) < lfThreshold) {
					motor[leftMotor1]  = 40;
					motor[leftMotor2]  = 40;
					motor[rightMotor1] = 40;
					motor[rightMotor2] = 40;
				}
				//If the left sensor sees light counter-steer to the left.
				else if(SensorValue(lineTrackerLeft) < lfThreshold){ //could be sersorValue[sensorName]
					motor[leftMotor1]  = 0;
					motor[leftMotor2]  = 0;
					motor[rightMotor1] = 40;
					motor[rightMotor2] = 40;
				}
				//If the right sensor sees light counter-steer to the right.
				else if(SensorValue(lineTrackerRight) < lfThreshold) {
					motor[leftMotor1]  = 40;
					motor[leftMotor2]  = 40;
					motor[rightMotor1] = 0;
					motor[rightMotor2] = 0;
				}
				//if (time1[T1] < 3000){
				//	motor[leftMotor] = 80;
				//	motor[rightMotor] = 80; //for auto without light sensors
				//}
			}
		}
	}
}

/**
* Teleop
**/
task usercontrol() {
	while (true) { //User control code goes in this while loop
		motor[leftMotor1]  = vexRT[Ch3];   // Left Joystick Y value
		motor[leftMotor2]  = vexRT[Ch3];
		motor[rightMotor1] = vexRT[Ch2];   // Right Joystick Y value
		motor[rightMotor2] = vexRT[Ch2];

		//Elevator
		//if button 5D is pressed, raise
		if(vexRT[Btn5D] == 1){
			//desLinkPos++;
			raiseElevator();
		}
		//if button 6D is pressed, lower
		else if (vexRT[Btn6D] == 1){
			//desLinkPos--;
			lowerElevator();
		}
		//otherwise, don't move
		//TODO change so that it is holding the weight, tho gravity should not be able to backdrive the motors.
		//May need some sort of control sensor to gain feedback from this elevator to account for the variable load
		else {
			motor[leftElevMotor] = 0;
			motor[rightElevMotor] = 0;
		}

		//Dustpan
		if(vexRT[Btn5U] == 1){
			retractPan();
			} else if(vexRT[Btn6U] == 1){
			extendPan();
			} else {
			motor[dustPanMotor] = 0;
		}

		//flip table automation
		if(vexRT[Btn7D]==1){
			flipTable();
		}


		//moveLinkage(desLinkPos);
	}
}
