#pragma config(Sensor, in5,    linkPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    lineTrackerLeft, sensorLineFollower)
#pragma config(Sensor, in7,    lineTrackerRight, sensorLineFollower)
#pragma config(Sensor, dgtl6,  panBottomSwitch, sensorTouch)
#pragma config(Sensor, dgtl7,  panSwitchFwd,   sensorTouch)
#pragma config(Sensor, dgtl8,  panSwitchRev,   sensorTouch)
#pragma config(Sensor, dgtl10, tableSwitch,    sensorTouch)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           leftLinkMotor, tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           dustPanMotor,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightLinkMotor, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(30) //The auto is 30 secs
#pragma userControlDuration(120) //The teleop is 2 mins

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Whenever this user program is run, the duration is automatically sent to the VEX master
// processor. The master CPU will only accept these commands once per power=on cycle. So, it's
// best to power cycle your VEX to ensure that they get recognized in case you were
// previously running a standard competition program with different durations.


// Testing Via VEXNET Using ROBOTC IDE
// ==================================================
//
// It is not necessary to own a VEXNET switch. ROBOTC has a test window that allows the same functionality.
// The test window has three buttons for "DISABLE", "AUTONOMOUS", "USER CONTROL".
//
// 1. Open the ROBOTC Debugger. Then open the "Competition Control" Debugger window.
//
// 2. Start your Driver Skills program running.
//
// 3. Click the "DISABLED" button on the "Competition Control" window.
//
// 4. Click the "USER CONTROL" button on the "Competition Control" window.
//
// 5. You need to manually time the 60 second duration.
//
// 6. Click the "DISABLED" button on the "Competition Control" window.
//
// 7. Repeat from step (4) to run subsequent test runs. There's no need to reset the VEX or
//    restart your user program.
//
/////////////////////////////////////////////////////////////////////////////////////////

void extendPan(){
	if(SensorValue(panSwitchFwd) == 0){
		motor[dustPanMotor] = 80; //is this too fast?
	} else {
		writeDebugStream("Pan is fully extended");
	}
}

void retractPan(){
	if(SensorValue(panSwitchRev) == 0){
		motor[dustPanMotor] = -80; //is this too fast?
	} else{
		writeDebugStream("Pan is fully retracted");
	}
}

/*Flips table by slowly going forward and raising the linkage*/
void flipTable(){
	int i = 0;
	int startTime;
	if(i == 0){
		startTime = time1[T1];
	}
	while(true){
		i = 1;
		motor[leftMotor]  = 10;
		motor[rightMotor] = 10;
		motor[leftLinkMotor] = 30;
		motor[rightLinkMotor] = 30;
		if(time1[T1] - startTime == 2000 || vexRT[Btn5D]){ //2 secs //manual control over an infinite loop
			motor[leftMotor] = 0;
			motor[rightMotor] = 0;
			motor[leftLinkMotor] = 0;
			motor[rightLinkMotor] = 0;
			break;
		}
	}
}

void raiseLinkage(){
	if(SensorValue(linkPot) < 135){
		motor[leftLinkMotor] = 100;//is this in percent?
		motor[rightLinkMotor] = 80;
	}
}

void lowerLinkage(){
	if(SensorValue(linkPot) > 0){
		motor[leftLinkMotor] = -100;
		motor[rightLinkMotor] = -100;
	}
}

/**
* Before game
* All activities that occur before the competition starts
* Example: clearing encoders, setting servo positions, ...
**/
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	clearTimer(T1); //it was spelled with "c" twice, while once with "C"
}

/**
* Auto
**/
task autonomous()
{
	//Create and set the threshold for the Line Tracking Sensors.
	//LineTrackers return 0-4095, where high values are dark and low values are light.
	int lfThreshold = 2500;

	//Loop forever.
	while(true)
	{
		//Lower linkage to the floor and fully extend the pan at the start of auto
		if(SensorValue[panBottomSwitch] == 0 || SensorValue(panSwitchFwd) == 0){
			while(SensorValue(panBottomSwitch) == 0){
				lowerLinkage();
			}
			while(SensorValue(panSwitchFwd) == 0){
				extendPan();
			}
		} else{
			//If table switch is pressed (if a table has been found), drive forward slowly while rasing the linkage. This will raise the table
			if(SensorValue(tableSwitch) == 1){
				flipTable();
			} else{
				//If both sensors see dark...
				if(SensorValue(lineTrackerLeft) > lfThreshold && SensorValue(lineTrackerRight) > lfThreshold) {
					//...move forward.
					motor[leftMotor]  = 40; //127 is full forward, -127 is full reverse or it might be out of 100%
					motor[rightMotor] = 40;
				}
				//If both sensors see light... (this is to clear the yellow tape in the starting box)
				else if(SensorValue(lineTrackerLeft) < lfThreshold && SensorValue(lineTrackerRight) < lfThreshold) {
					//...move forward.
					motor[leftMotor]  = 40;
					motor[rightMotor] = 40;
				}
				//If the left sensor sees light...
				else if(SensorValue(lineTrackerLeft) < lfThreshold){ //could be sersorValue[sensorName]
					//...counter-steer to the left.
					motor[leftMotor]  = 0;
					motor[rightMotor] = 40;
				}
				//If the right sensor sees light...
				else if(SensorValue(lineTrackerRight) < lfThreshold) {
					//...counter-steer to the right.
					motor[leftMotor]  = 40;
					motor[rightMotor] = 0;
				}
				else {
					motor[leftMotor] = 0;
					motor[rightMotor] = 0;
				}
			}
		}
	}
}

/**
* Teleop
**/
task usercontrol()
{
	while (true)
	{
		//User control code goes in this while loop
		motor[leftMotor]  = vexRT[Ch3];   // Left Joystick Y value
		motor[rightMotor] = vexRT[Ch2];   // Right Joystick Y value

		//4-Bar Linkage
		//if button 5D is pressed, raise
		if(vexRT[Btn5D] == 1){
			raiseLinkage();
		}
		//if button 6D is pressed, lower
		else if (vexRT[Btn6D] == 1){
			lowerLinkage();
		}
		//otherwise, do not do anything
		else{
			motor[leftLinkMotor] = 0;
			motor[rightLinkMotor] = 0;
		}

		//Dustpan
		if(vexRT[Btn8R] == 1){ //change button according to what the driver wants
			extendPan();
		} else if(vexRT[Btn8L]){
			retractPan();
		} else {
			motor[dustPanMotor] = 0;
		}

		//flip table automation
		if(vexRT[Btn7D]){
			flipTable();
		}
	}
}
