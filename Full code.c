#pragma config(Sensor, in1,    linkPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    lineTrackerLeft, sensorLineFollower)
#pragma config(Sensor, in7,    lineTrackerRight, sensorLineFollower)
#pragma config(Sensor, dgtl1,  panSwitchRev,   sensorTouch)
#pragma config(Sensor, dgtl2,  panSwitchFwd,   sensorTouch)
#pragma config(Sensor, dgtl3,  tableSwitch,    sensorTouch)
#pragma config(Motor,  port1,           leftMotor1,    tmotorVex393_HBridge, openLoop, reversed, driveLeft)
#pragma config(Motor,  port2,           leftMotor2,    tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           leftLinkMotor, tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           dustPanMotor,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightLinkMotor, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           rightMotor2,   tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          rightMotor1,   tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(30) //The auto is 30 secs
#pragma userControlDuration(120) //The teleop is 2 mins

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Whenever this user program is run, the duration is automatically sent to the VEX master
// processor. The master CPU will only accept these commands once per power=on cycle. So, it's
// best to power cycle your VEX to ensure that they get recognized in case you were
// previously running a standard competition program with different durations.


// Testing Via VEXNET Using ROBOTC IDE
// ==================================================
//
// It is not necessary to own a VEXNET switch. ROBOTC has a test window that allows the same functionality.
// The test window has three buttons for "DISABLE", "AUTONOMOUS", "USER CONTROL".
//
// 1. Open the ROBOTC Debugger. Then open the "Competition Control" Debugger window.
//
// 2. Start your Driver Skills program running.
//
// 3. Click the "DISABLED" button on the "Competition Control" window.
//
// 4. Click the "USER CONTROL" button on the "Competition Control" window.
//
// 5. You need to manually time the 60 second duration.
//
// 6. Click the "DISABLED" button on the "Competition Control" window.
//
// 7. Repeat from step (4) to run subsequent test runs. There's no need to reset the VEX or
//    restart your user program.
//
/////////////////////////////////////////////////////////////////////////////////////////

void extendPan(){
	if(SensorValue(panSwitchFwd) == 0){
		motor[dustPanMotor] = 80; //is this too fast?
		} else {
		writeDebugStream("Pan is fully extended");
	}
}

void retractPan(){
	if(SensorValue(panSwitchRev) == 0){
		motor[dustPanMotor] = -80; //is this too fast?
		} else{
		writeDebugStream("Pan is fully retracted");
	}
}

void raiseLinkage(){
	if(SensorValue(linkPot) < 135){
		motor[leftLinkMotor] 	= 100;//is this in percent?
		motor[rightLinkMotor] = 100;
	}
}

void lowerLinkage(){
	if(SensorValue(linkPot) > 0){
		motor[leftLinkMotor] 	= -100;
		motor[rightLinkMotor] = -100;
	}
}

/*Flips table by slowly going forward and raising the linkage*/
void flipTable(){
	int i = 0;
	int startTime;
	if(i == 0){
		startTime = time1[T1];
	}
	while(true){
		i = 1;
		motor[leftMotor1]  		= 10;
		motor[leftMotor2]  		= 10;
		motor[rightMotor1] 		= 10;
		motor[rightMotor2] 		= 10;
		motor[leftLinkMotor] 	= 30;
		motor[rightLinkMotor] = 30;
		if(time1[T1] - startTime == 2000 || vexRT[Btn8D]){ //2 secs //manual control over an infinite loop
			motor[leftMotor1] 		= 0;
			motor[leftMotor2] 		= 0;
			motor[rightMotor1] 		= 0;
			motor[rightMotor2]    = 0;
			motor[leftLinkMotor]  = 0;
			motor[rightLinkMotor] = 0;
			break;
		}
	}
}

/**
* Before game
* All activities that occur before the competition starts
* Example: clearing encoders, setting servo positions, ...
**/
void pre_auton() {
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	clearTimer(T1); //it was spelled with "c" twice, while once with "C"
}

/**
* Auto
**/
task autonomous() {
	//Create and set the threshold for the Line Tracking Sensors.
	//LineTrackers return 0-4095, where high values are dark and low values are light.
	int lfThreshold = 2500;

	//Loop forever.
	while(true) {
		//Lower linkage to the floor and fully extend the pan at the start of auto
		if(SensorValue[linkPot] > 0 || SensorValue(panSwitchFwd) == 0){
			lowerLinkage();
			extendPan();
			} else{
			//If table switch is pressed (if a table has been found), drive forward slowly while rasing the linkage. This will theoretically raise the table
			if(SensorValue(tableSwitch) == 1){
				flipTable();
				} else{
				//If both sensors see dark move forward.
				if(SensorValue(lineTrackerLeft) > lfThreshold && SensorValue(lineTrackerRight) > lfThreshold) {
					motor[leftMotor1]  = 40; //127 is full forward, -127 is full reverse or it might be out of 100%
					motor[leftMotor2]  = 40;
					motor[rightMotor1] = 40;
					motor[rightMotor2] = 40;
				}
				//If both sensors see light move forward (this is to clear the yellow tape in the starting box)
				else if(SensorValue(lineTrackerLeft) < lfThreshold && SensorValue(lineTrackerRight) < lfThreshold) {
					motor[leftMotor1]  = 40;
					motor[leftMotor2]  = 40;
					motor[rightMotor1] = 40;
					motor[rightMotor2] = 40;
				}
				//If the left sensor sees light counter-steer to the left.
				else if(SensorValue(lineTrackerLeft) < lfThreshold){ //could be sersorValue[sensorName]
					motor[leftMotor1]  = 0;
					motor[leftMotor2]  = 0;
					motor[rightMotor1] = 40;
					motor[rightMotor2] = 40;
				}
				//If the right sensor sees light counter-steer to the right.
				else if(SensorValue(lineTrackerRight) < lfThreshold) {
					motor[leftMotor1]  = 40;
					motor[leftMotor2]  = 40;
					motor[rightMotor1] = 0;
					motor[rightMotor2] = 0;
				}
				//if (time1[T1] < 3000){
				//	motor[leftMotor] = 80;
				//	motor[rightMotor] = 80; //for auto without light sensors
				//}
			}
		}
	}
}

/**
* Teleop
**/
task usercontrol() {
	while (true) { //User control code goes in this while loop
		motor[leftMotor1]  = vexRT[Ch3];   // Left Joystick Y value
		motor[leftMotor2]  = vexRT[Ch3];
		motor[rightMotor1] = vexRT[Ch2];   // Right Joystick Y value
		motor[rightMotor2] = vexRT[Ch2];

		//4-Bar Linkage
		//if button 5D is pressed, raise
		if(vexRT[Btn5D] == 1){
			raiseLinkage();
		}
		//if button 6D is pressed, lower
		else if (vexRT[Btn6D] == 1){
			lowerLinkage();
		}
		//otherwise, do not do anything
		else{
			motor[leftLinkMotor] = 0;
			motor[rightLinkMotor] = 0;
		}

		//Dustpan
		if(vexRT[Btn7L] == 1){ //change button according to what the driver wants
			retractPan();
			} else if(vexRT[Btn8R]){
			extendPan();
			} else {
			motor[dustPanMotor] = 0;
		}

		//flip table automation
		if(vexRT[Btn7D]){
			flipTable();
		}
	}
}
