{
	"folder_history":
	[
	],
	"last_window_id": 1,
	"settings":
	{
	},
	"windows":
	[
		{
			"auto_complete":
			{
				"selected_items":
				[
				]
			},
			"buffers":
			[
				{
					"contents": "#pragma config(Sensor, in6,    lineTrackerLeft, sensorLineFollower)\n#pragma config(Sensor, in7,    lineTrackerRight, sensorLineFollower)\n#pragma config(Sensor, dgtl10, limitSwitch,    sensorTouch)\n#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft)\n#pragma config(Motor,  port9,           thingMotor,    tmotorVex393_MC29, openLoop)\n#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, driveRight)\n//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//\n\n#pragma platform(VEX)\n\n\n//Competition Control and Duration Settings\n#pragma competitionControl(Competition)\n#pragma autonomousDuration(30) //is this how you control how long the things last?\n#pragma userControlDuration(60)\n\n#include \"Vex_Competition_Includes.c\"   //Main competition background code...do not modify!\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//\n//                         Driver Skills Template\n//\n// This is a template for the driver skills competition. It is identical in structure to\n// the standard competition template except that the two \"#pragma' statements above (and\n// copied below) adjust the time limits for the competition.\n//				#pragma autonomousDuration(0)\n//				#pragma userControlDuration(60)\n// The autonomous duration for \"Driver Skills\" is zero; i.e. there is no autonomous phase.\n// The user control duration is 60 seconds\n//\n// NOTE: The above two pragmas only impact the Crystal implementation. For systems using\n//       VEXNET, the VEXNET system ignores these statements as it has the durations\n//       for the competition built-in.\n//\n// Whenever this user program is run, the duration is automatically sent to the VEX master\n// processor. The master CPU will only accept these commands once per power=on cycle. So, it's\n// best to power cycle your VEX to ensure that they get recognized in case you were\n// previously running a standard competition program with different durations.\n//\n// Testing Via Crystals:\n// ====================\n//\n// The procedure to test a Driver Skills program using the crystals is as follows:\n//\n// 1. Turn off power to the Crystal transmitter/joysticks.\n//\n// 2. Turn on your VEX so that the Driver Skills program is running.\n//\n// 3. Driver skills program segment of your program will start running. At the end of 60\n//    seconds the VEX Master CPU will turn off the motors.\n//\n// 4. Repeat the above sequence\n//\n//\n// Testing Via VEXNET Using VEXNET Competition Switch\n// ==================================================\n//\n// The procedure to test a Driver Skills program using VEXNET Competition Switch is as follows:\n//\n// 1. Set the two switches on the Competition switch to \"DISABLE\" and \"USER CONTROL\"\n//\n// 2. Start the Driver skills program\n//\n// 3. Set Switch to ENABLE from DISABLE\n//\n// 4. You need to manually time the 60 second duration.\n//\n// 5. Set Switch to DISABLE\n//\n// 6. Repeat from step (3) to run subsequent test runs. There's no need to reset the VEX or\n//    restart your user program.\n//\n//\n// Testing Via VEXNET Using ROBOTC IDE\n// ==================================================\n//\n// It is not necessary to own a VEXNET switch. ROBOTC has a test window that allows the same functionality.\n// The test window has three buttons for \"DISABLE\", \"AUTONOMOUS\", \"USER CONTROL\".\n//\n// 1. Open the ROBOTC Debugger. Then open the \"Competition Control\" Debugger window.\n//\n// 2. Start your Driver Skills program running.\n//\n// 3. Click the \"DISABLED\" button on the \"Competition Control\" window.\n//\n// 4. Click the \"USER CONTROL\" button on the \"Competition Control\" window.\n//\n// 5. You need to manually time the 60 second duration.\n//\n// 6. Click the \"DISABLED\" button on the \"Competition Control\" window.\n//\n// 7. Repeat from step (4) to run subsequent test runs. There's no need to reset the VEX or\n//    restart your user program.\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//\n//                          Pre-Autonomous Functions\n//\n// You may want to perform some actions before the competition starts. Do them in the\n// following function.\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\nvoid pre_auton()\n{\n	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between\n	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.\n	bStopTasksBetweenModes = true;\n\n	// All activities that occur before the competition starts\n	// Example: clearing encoders, setting servo positions, ...\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//\n//                                 Autonomous Task\n//\n// The \"Driver Skills\" competition has no autonomous phase. Simply leave the following\n// placeholder.\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\ntask autonomous()\n{\n	clearTimer(T1);\n	//Create and set the threshold for the Line Tracking Sensors.\n	//LineTrackers return 0-4095, where high values are dark and low values are light.\n	int threshold;\n	threshold = 2500;\n\n	//Loop forever.\n	while(true)\n	{\n		////Go forward to clear the box tape (yellow is very similar to the retreflective) to not confuse the line follower\n		//if(time1[T1] <= 500)\n		//{\n		//	motor[leftMotor]  = 40;\n		//	motor[rightMotor] = 40;\n		//}\n		////Once the tape has been cleared, follow the line.\n		//else\n		//{\n			//If both sensors see dark...\n			if(SensorValue(lineTrackerLeft ) > threshold && SensorValue(lineTrackerRight) > threshold)\n			{\n				//...move forward.\n				motor[leftMotor]  = 40;\n				motor[rightMotor] = 40;\n			}\n			//If both sensors see light... (this is to clear the yellow tape in the starting box)\n			else if(SensorValue(lineTrackerLeft ) < threshold && SensorValue(lineTrackerRight) < threshold)\n			{\n				//...move forward.\n				motor[leftMotor]  = 40;\n				motor[rightMotor] = 40;\n			}\n			//If the left sensor sees light...\n			else if(SensorValue(lineTrackerLeft) < threshold)\n			{\n				//...counter-steer to the left.\n				motor[leftMotor]  = 0;\n				motor[rightMotor] = 40;\n			}\n			//If the right sensor sees light...\n			else if(SensorValue(lineTrackerRight) < threshold)\n			{\n				//...counter-steer to the right.\n				motor[leftMotor]  = 40;\n				motor[rightMotor] = 0;\n			}\n\n			//If switch is pressed...\n			if(SensorValue(limitSwitch)){\n				//...stop moving\n				motor[leftMotor]  = 0;\n				motor[rightMotor] = 0;\n			}\n		//}\n	}\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////\n//\n//                                 User Control Task\n//\n// This task is used to control your robot during the user control phase of a VEX Competition.\n// You must modify the code to add your own robot specific commands here.\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\ntask usercontrol()\n{\n	// User control code here, inside the loop\n\n	while (true)\n	{\n		// This is the main execution loop for the user control program. Each time through the loop\n		// your program should update motor + servo values based on feedback from the joysticks.\n\n		// .....................................................................................\n		// Insert user code here. This is where you use the joystick values to update your motors, etc.\n		// .....................................................................................\n\n		while(true)\n		{\n			motor[leftMotor]  = vexRT[Ch3];   // Left Joystick Y value\n			motor[rightMotor] = vexRT[Ch2];   // Right Joystick Y value\n			\n			//if button 5D is pressed, rotate one way\n			if(vexRT[Btn5D] == 1)\n			{\n				motor[thingMotor] = 80;\n			}\n			//if button 6D is pressed, rotater the other way\n			else if (vexRT[Btn6D] == 1)\n			{\n				motor[thingMotor] = -80;\n			}\n			//otherwise, do not rotate\n			else\n			{\n				motor[thingMotor] = 0;\n			}\n		}\n	}\n}",
					"settings":
					{
						"buffer_size": 8110,
						"line_ending": "Windows",
						"name": "#pragma config(Sensor, in6,    lineTrackerLeft, se"
					}
				}
			],
			"build_system": "Packages/User/RobotC.sublime-build",
			"command_palette":
			{
				"height": 0.0,
				"selected_items":
				[
				],
				"width": 0.0
			},
			"console":
			{
				"height": 0.0
			},
			"distraction_free":
			{
				"menu_visible": true,
				"show_minimap": false,
				"show_open_files": false,
				"show_tabs": false,
				"side_bar_visible": false,
				"status_bar_visible": false
			},
			"file_history":
			[
				"/C/Users/Aravind/Documents/VEX/Moving Forward.c",
				"/C/Users/Aravind/Documents/VEX/Modifying Values new.c"
			],
			"find":
			{
				"height": 34.0
			},
			"find_in_files":
			{
				"height": 0.0,
				"where_history":
				[
					""
				]
			},
			"find_state":
			{
				"case_sensitive": false,
				"find_history":
				[
					"App",
					"\"",
					"bat"
				],
				"highlight": true,
				"in_selection": false,
				"preserve_case": false,
				"regex": false,
				"replace_history":
				[
					""
				],
				"reverse": false,
				"show_context": true,
				"use_buffer2": true,
				"whole_word": false,
				"wrap": true
			},
			"groups":
			[
				{
					"selected": 0,
					"sheets":
					[
						{
							"buffer": 0,
							"settings":
							{
								"buffer_size": 8110,
								"regions":
								{
								},
								"selection":
								[
									[
										8110,
										8110
									]
								],
								"settings":
								{
									"auto_name": "#pragma config(Sensor, in6,    lineTrackerLeft, se",
									"syntax": "Packages/Text/Plain text.tmLanguage",
									"translate_tabs_to_spaces": false
								},
								"translation.x": 0.0,
								"translation.y": 2805.0,
								"zoom_level": 1.0
							},
							"type": "text"
						}
					]
				}
			],
			"incremental_find":
			{
				"height": 0.0
			},
			"input":
			{
				"height": 0.0
			},
			"layout":
			{
				"cells":
				[
					[
						0,
						0,
						1,
						1
					]
				],
				"cols":
				[
					0.0,
					1.0
				],
				"rows":
				[
					0.0,
					1.0
				]
			},
			"menu_visible": true,
			"output.exec":
			{
				"height": 273.0
			},
			"position": "0,0,1,-1,-1,-1,-1,913,116,184,1376",
			"replace":
			{
				"height": 0.0
			},
			"save_all_on_build": true,
			"select_file":
			{
				"height": 0.0,
				"selected_items":
				[
				],
				"width": 0.0
			},
			"select_project":
			{
				"height": 0.0,
				"selected_items":
				[
				],
				"width": 0.0
			},
			"show_minimap": true,
			"show_open_files": false,
			"show_tabs": true,
			"side_bar_visible": true,
			"side_bar_width": 150.0,
			"status_bar_visible": true,
			"window_id": 1,
			"workspace_name": ""
		}
	],
	"workspaces":
	{
		"recent_workspaces":
		[
		]
	}
}
